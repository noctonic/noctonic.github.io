<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Perlin Noise + Helix Colors</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden;
      background: #222;
      font-family: sans-serif;
      color: #eee;
    }
    #controlPanel {
      position: absolute;
      top: 10px; left: 10px;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
    }
    label {
      display: block;
      margin: 6px 0 3px;
    }
    input[type=range] {
      width: 150px;
    }

  </style>
</head>
<body>

<canvas id="noiseCanvas"></canvas>

<div id="controlPanel">
  <label for="speedSlider">Speed</label>
  <input id="speedSlider" type="range" min="0" max="5" step="0.01" value="0.25">

  <label for="scaleSlider">Zoom</label>
  <input id="scaleSlider" type="range" min="1" max="10" step="0.01" value="5">

  <label for="amplitudeSlider">Amplitude</label>
  <input id="amplitudeSlider" type="range" min="0.1" max="10.0" step="0.1" value="2.0">

  <label for="paletteCountSlider">Colors</label>
  <input id="paletteCountSlider" type="range" min="2" max="256" step="1" value="256">

  <label for="transitionSlider">Time</label>
  <input id="transitionSlider" type="range" min="1" max="15" step="1" value="5">

</div>

<script src="./color_utils/colorConversion.js"></script>
<script src="./color_utils/helix_colors.js"></script>
<script type="module">

  function getDynamicHelixParams(time) {
    return {
      startZ:   -0.50 + 0.25 * Math.sin(time * 0.41),
      endZ:      0.50 + 0.25 * Math.cos(time * 0.52),
      turns:     0 + 2.0 * Math.sin(time * 0.56),
      amplitude: 0 + 2.0 * Math.cos(time * 0.75),
      direction: 0 + 2.0 * Math.cos(time * 0.38),
      initialAngleDeg: (time * 1.0) % 360,
      scaleX: 0 + 2.0 * Math.sin(time * 0.12),
      scaleZ: 0 + 2.0 * Math.cos(time * 0.34),
      maxChroma: 130
    };
  }

  const canvas = document.getElementById('noiseCanvas');
  const gl = canvas.getContext('webgl');
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();
  if (!gl) {
    alert('WebGL not supported in this browser!');
    throw new Error('WebGL not supported');
  }

  const vertexShaderSource = `
  attribute vec2 aPosition;
  varying vec2 vUV;
  void main() {
    vUV = (aPosition + 1.0) * 0.5;
    gl_Position = vec4(aPosition, 0.0, 1.0);
  }
  `;

  const fragmentShaderSource = `
  precision highp float;
  varying vec2 vUV;

  uniform float uZOffset;
  uniform float uScale;
  uniform float uAmplitude;
  uniform float uTransitionAlpha;
  uniform sampler2D uOldPalette;
  uniform sampler2D uNewPalette;
  uniform float uPaletteSize;

  float fade(float t) {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
  }

  float random3(vec3 p) {
    float dotVal = dot(p, vec3(127.1, 311.7, 74.7));
    return fract(sin(dotVal) * 43758.5453);
  }

  vec3 grad3(vec3 p) {
    float r = random3(p);
    float theta = 2.0 * 3.141592653589793 * r;
    float r2 = fract(r * 13.7);
    float z = r2 * 2.0 - 1.0;
    float s = sqrt(1.0 - z*z);
    return vec3(s * cos(theta), s * sin(theta), z);
  }

  float perlinNoise3D(vec3 p) {
    vec3 i0 = floor(p);
    vec3 i1 = i0 + vec3(1.0);
    vec3 f  = fract(p);
    vec3 u  = vec3(fade(f.x), fade(f.y), fade(f.z));

    vec3 c000 = i0;
    vec3 c100 = vec3(i1.x, i0.y, i0.z);
    vec3 c010 = vec3(i0.x, i1.y, i0.z);
    vec3 c110 = vec3(i1.x, i1.y, i0.z);
    vec3 c001 = vec3(i0.x, i0.y, i1.z);
    vec3 c101 = vec3(i1.x, i0.y, i1.z);
    vec3 c011 = vec3(i0.x, i1.y, i1.z);
    vec3 c111 = i1;

    vec3 g000 = grad3(c000);
    vec3 g100 = grad3(c100);
    vec3 g010 = grad3(c010);
    vec3 g110 = grad3(c110);
    vec3 g001 = grad3(c001);
    vec3 g101 = grad3(c101);
    vec3 g011 = grad3(c011);
    vec3 g111 = grad3(c111);

    vec3 d000 = p - c000;
    vec3 d100 = p - c100;
    vec3 d010 = p - c010;
    vec3 d110 = p - c110;
    vec3 d001 = p - c001;
    vec3 d101 = p - c101;
    vec3 d011 = p - c011;
    vec3 d111 = p - c111;

    float n000 = dot(g000, d000);
    float n100 = dot(g100, d100);
    float n010 = dot(g010, d010);
    float n110 = dot(g110, d110);
    float n001 = dot(g001, d001);
    float n101 = dot(g101, d101);
    float n011 = dot(g011, d011);
    float n111 = dot(g111, d111);

    float nx00 = mix(n000, n100, u.x);
    float nx01 = mix(n001, n101, u.x);
    float nx10 = mix(n010, n110, u.x);
    float nx11 = mix(n011, n111, u.x);

    float nxy0 = mix(nx00, nx10, u.y);
    float nxy1 = mix(nx01, nx11, u.y);

    float nxyz = mix(nxy0, nxy1, u.z);
    return nxyz; // -1..1
  }

  void main() {
    // Compute Perlin noise
    vec3 pos3 = vec3(vUV.x * uScale, vUV.y * uScale, uZOffset);
    float n = perlinNoise3D(pos3);
    float val = (n + 1.0) * 0.5;
    val *= uAmplitude;
    val = fract(val);

    // "Index" into our 1D color palette
    float index = val * (uPaletteSize - 1.0);
    vec2 texCoord = vec2(index / uPaletteSize, 0.0);

    // Sample from old and new palettes
    vec4 oldCol = texture2D(uOldPalette, texCoord);
    vec4 newCol = texture2D(uNewPalette, texCoord);

    // Mix based on transition alpha
    vec4 color = mix(oldCol, newCol, uTransitionAlpha);
    gl_FragColor = color;
  }
  `;

  function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
  }
  gl.useProgram(program);

  const quadVertices = new Float32Array([
    -1, -1,
     1, -1,
    -1,  1,
     1, -1,
     1,  1,
    -1,  1
  ]);
  const vbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, quadVertices, gl.STATIC_DRAW);

  const aPositionLoc = gl.getAttribLocation(program, "aPosition");
  gl.enableVertexAttribArray(aPositionLoc);
  gl.vertexAttribPointer(aPositionLoc, 2, gl.FLOAT, false, 0, 0);

  const uZOffsetLoc         = gl.getUniformLocation(program, "uZOffset");
  const uScaleLoc           = gl.getUniformLocation(program, "uScale");
  const uAmplitudeLoc       = gl.getUniformLocation(program, "uAmplitude");
  const uTransitionAlphaLoc = gl.getUniformLocation(program, "uTransitionAlpha");
  const uOldPaletteLoc      = gl.getUniformLocation(program, "uOldPalette");
  const uNewPaletteLoc      = gl.getUniformLocation(program, "uNewPalette");
  const uPaletteSizeLoc     = gl.getUniformLocation(program, "uPaletteSize");

  let oldColors = [];
  let newColors = [];

  let paletteTextureOld = null;
  let paletteTextureNew = null;

  let transitionAlpha = 0;
  let transitionStartTime = 0;
  let isTransitioning = false;

  let transitionDuration = 5000;
  let paletteSizeSetting = 256;

  let zOffset         = Math.random() * 10000;
  let noiseSpeed      = 0.25;
  let noiseScale      = 5.0;
  let noiseAmplitude  = 2.0;
  let lastTime        = 0.0;

  function createPaletteTexture(colors) {
    const size = colors.length;
    const data = new Uint8Array(size * 4);
    for (let i = 0; i < size; i++) {
      data[i * 4 + 0] = colors[i][0];
      data[i * 4 + 1] = colors[i][1];
      data[i * 4 + 2] = colors[i][2];
      data[i * 4 + 3] = 255;
    }
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(
      gl.TEXTURE_2D, 0, gl.RGBA,
      size, 1, 0,
      gl.RGBA, gl.UNSIGNED_BYTE, data
    );
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    return texture;
  }

  paletteTextureOld = createPaletteTexture([]);
  paletteTextureNew = createPaletteTexture([]);

  const randomOffset = Math.random() * 10000;

  function generateNewPalette() {
    const nowSec = (performance.now() + randomOffset) * 0.001; 
    oldColors = newColors;

    const helixParams = getDynamicHelixParams(nowSec);
    const helixColorsHex = getHelixColors(
      helixParams, 
      paletteSizeSetting, 
      helixParams.maxChroma
    );
    const paletteRGB = helixColorsHex.map(hex => hex2rgb(hex));
    newColors = paletteRGB;

    gl.deleteTexture(paletteTextureOld);
    gl.deleteTexture(paletteTextureNew);
    paletteTextureOld = createPaletteTexture(oldColors);
    paletteTextureNew = createPaletteTexture(newColors);
  }


  function render(now) {
    const dt = (now - lastTime) * 0.001;
    lastTime = now;

    zOffset += noiseSpeed * dt;

    if (isTransitioning) {
      const elapsed = now - transitionStartTime;
      transitionAlpha = Math.min(1.0, elapsed / transitionDuration);
      if (transitionAlpha >= 1.0) {
        isTransitioning = false;
      }
    }

    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.uniform1f(uZOffsetLoc, zOffset);
    gl.uniform1f(uScaleLoc, noiseScale);
    gl.uniform1f(uAmplitudeLoc, noiseAmplitude);
    gl.uniform1f(uTransitionAlphaLoc, transitionAlpha);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, paletteTextureOld);
    gl.uniform1i(uOldPaletteLoc, 0);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, paletteTextureNew);
    gl.uniform1i(uNewPaletteLoc, 1);

    const paletteSize = Math.max(oldColors.length, newColors.length);
    gl.uniform1f(uPaletteSizeLoc, paletteSize);

    gl.drawArrays(gl.TRIANGLES, 0, 6);
    requestAnimationFrame(render);
  }

  generateNewPalette();
  transitionAlpha = 1.0;
  requestAnimationFrame(render);


  function startPaletteCycle() {
    transitionAlpha = 1.0;
    isTransitioning = false;

    setTimeout(() => {
      generateNewPalette();
      transitionAlpha = 0.0;
      transitionStartTime = performance.now();
      isTransitioning = true;

      setTimeout(() => {
        startPaletteCycle();  // loop forever
      }, transitionDuration);

    }, transitionDuration);
  }

  startPaletteCycle();


  const speedSlider = document.getElementById("speedSlider");
  speedSlider.addEventListener("input", () => {
    noiseSpeed = parseFloat(speedSlider.value);
  });

  const scaleSlider = document.getElementById("scaleSlider");
  scaleSlider.addEventListener("input", () => {
    noiseScale = parseFloat(scaleSlider.value);
  });

  const amplitudeSlider = document.getElementById("amplitudeSlider");
  amplitudeSlider.addEventListener("input", () => {
    noiseAmplitude = parseFloat(amplitudeSlider.value);
  });

  const paletteCountSlider = document.getElementById("paletteCountSlider");
  paletteCountSlider.addEventListener("input", () => {
    paletteSizeSetting = parseInt(paletteCountSlider.value);
  });

  const transitionSlider = document.getElementById("transitionSlider");
  transitionSlider.addEventListener("input", () => {
    transitionDuration = parseInt(transitionSlider.value) * 1000;
  });

</script>
</body>
</html>
