{"date":"---------------------------------------------------------------------------------------\n-- Module for date and time calculations\n--\n-- Version 2.2.1\n-- Copyright (C) 2005-2006, by Jas Latrix (jastejada@yahoo.com)\n-- Copyright (C) 2013-2021, by Thijs Schreijer\n-- Licensed under MIT, http://opensource.org/licenses/MIT\n\n--[[ CONSTANTS ]]--\n  local HOURPERDAY  = 24\n  local MINPERHOUR  = 60\n  local MINPERDAY    = 1440  -- 24*60\n  local SECPERMIN   = 60\n  local SECPERHOUR  = 3600  -- 60*60\n  local SECPERDAY   = 86400 -- 24*60*60\n  local TICKSPERSEC = 1000000\n  local TICKSPERDAY = 86400000000\n  local TICKSPERHOUR = 3600000000\n  local TICKSPERMIN = 60000000\n  local DAYNUM_MAX =  365242500 -- Sat Jan 01 1000000 00:00:00\n  local DAYNUM_MIN = -365242500 -- Mon Jan 01 1000000 BCE 00:00:00\n  local DAYNUM_DEF =  0 -- Mon Jan 01 0001 00:00:00\n  local _;\n--[[ GLOBAL SETTINGS ]]--\n  local centuryflip = 0 -- year >= centuryflip == 1900, < centuryflip == 2000\n--[[ LOCAL ARE FASTER ]]--\n  local type     = type\n  local pairs    = pairs\n  local error    = error\n  local assert   = assert\n  local tonumber = tonumber\n  local tostring = tostring\n  local string   = string\n  local math     = math\n  local os       = os\n  local unpack   = unpack or table.unpack\n  local setmetatable = setmetatable\n  local getmetatable = getmetatable\n--[[ EXTRA FUNCTIONS ]]--\n  local fmt  = string.format\n  local lwr  = string.lower\n  local rep  = string.rep\n  local len  = string.len  -- luacheck: ignore\n  local sub  = string.sub\n  local gsub = string.gsub\n  local gmatch = string.gmatch or string.gfind\n  local find = string.find\n  local ostime = os.time\n  local osdate = os.date\n  local floor = math.floor\n  local ceil  = math.ceil\n  local abs   = math.abs\n  -- removes the decimal part of a number\n  local function fix(n) n = tonumber(n) return n and ((n > 0 and floor or ceil)(n)) end\n  -- returns the modulo n % d;\n  local function mod(n,d) return n - d*floor(n/d) end\n  -- is `str` in string list `tbl`, `ml` is the minimun len\n  local function inlist(str, tbl, ml, tn)\n    local sl = len(str)\n    if sl < (ml or 0) then return nil end\n    str = lwr(str)\n    for k, v in pairs(tbl) do\n      if str == lwr(sub(v, 1, sl)) then\n        if tn then tn[0] = k end\n        return k\n      end\n    end\n  end\n  local function fnil() end\n--[[ DATE FUNCTIONS ]]--\n  local DATE_EPOCH -- to be set later\n  local sl_weekdays = {\n    [0]=\"Sunday\",[1]=\"Monday\",[2]=\"Tuesday\",[3]=\"Wednesday\",[4]=\"Thursday\",[5]=\"Friday\",[6]=\"Saturday\",\n    [7]=\"Sun\",[8]=\"Mon\",[9]=\"Tue\",[10]=\"Wed\",[11]=\"Thu\",[12]=\"Fri\",[13]=\"Sat\",\n  }\n  local sl_meridian = {[-1]=\"AM\", [1]=\"PM\"}\n  local sl_months = {\n    [00]=\"January\", [01]=\"February\", [02]=\"March\",\n    [03]=\"April\",   [04]=\"May\",      [05]=\"June\",\n    [06]=\"July\",    [07]=\"August\",   [08]=\"September\",\n    [09]=\"October\", [10]=\"November\", [11]=\"December\",\n    [12]=\"Jan\", [13]=\"Feb\", [14]=\"Mar\",\n    [15]=\"Apr\", [16]=\"May\", [17]=\"Jun\",\n    [18]=\"Jul\", [19]=\"Aug\", [20]=\"Sep\",\n    [21]=\"Oct\", [22]=\"Nov\", [23]=\"Dec\",\n  }\n  -- added the '.2'  to avoid collision, use `fix` to remove\n  local sl_timezone = {\n    [000]=\"utc\",    [0.2]=\"gmt\",\n    [300]=\"est\",    [240]=\"edt\",\n    [360]=\"cst\",  [300.2]=\"cdt\",\n    [420]=\"mst\",  [360.2]=\"mdt\",\n    [480]=\"pst\",  [420.2]=\"pdt\",\n  }\n  -- set the day fraction resolution\n  local function setticks(t)\n    TICKSPERSEC = t;\n    TICKSPERDAY = SECPERDAY*TICKSPERSEC\n    TICKSPERHOUR= SECPERHOUR*TICKSPERSEC\n    TICKSPERMIN = SECPERMIN*TICKSPERSEC\n  end\n  -- is year y leap year?\n  local function isleapyear(y) -- y must be int!\n    return (mod(y, 4) == 0 and (mod(y, 100) ~= 0 or mod(y, 400) == 0))\n  end\n  -- day since year 0\n  local function dayfromyear(y) -- y must be int!\n    return 365*y + floor(y/4) - floor(y/100) + floor(y/400)\n  end\n  -- day number from date, month is zero base\n  local function makedaynum(y, m, d)\n    local mm = mod(mod(m,12) + 10, 12)\n    return dayfromyear(y + floor(m/12) - floor(mm/10)) + floor((mm*306 + 5)/10) + d - 307\n    --local yy = y + floor(m/12) - floor(mm/10)\n    --return dayfromyear(yy) + floor((mm*306 + 5)/10) + (d - 1)\n  end\n  -- date from day number, month is zero base\n  local function breakdaynum(g)\n    local g = g + 306\n    local y = floor((10000*g + 14780)/3652425)\n    local d = g - dayfromyear(y)\n    if d < 0 then y = y - 1; d = g - dayfromyear(y) end\n    local mi = floor((100*d + 52)/3060)\n    return (floor((mi + 2)/12) + y), mod(mi + 2,12), (d - floor((mi*306 + 5)/10) + 1)\n  end\n  --[[ for floats or int32 Lua Number data type\n  local function breakdaynum2(g)\n    local g, n = g + 306;\n    local n400 = floor(g/DI400Y);n = mod(g,DI400Y);\n    local n100 = floor(n/DI100Y);n = mod(n,DI100Y);\n    local n004 = floor(n/DI4Y);   n = mod(n,DI4Y);\n    local n001 = floor(n/365);   n = mod(n,365);\n    local y = (n400*400) + (n100*100) + (n004*4) + n001  - ((n001 == 4 or n100 == 4) and 1 or 0)\n    local d = g - dayfromyear(y)\n    local mi = floor((100*d + 52)/3060)\n    return (floor((mi + 2)/12) + y), mod(mi + 2,12), (d - floor((mi*306 + 5)/10) + 1)\n  end\n  ]]\n  -- day fraction from time\n  local function makedayfrc(h,r,s,t)\n    return ((h*60 + r)*60 + s)*TICKSPERSEC + t\n  end\n  -- time from day fraction\n  local function breakdayfrc(df)\n    return\n      mod(floor(df/TICKSPERHOUR),HOURPERDAY),\n      mod(floor(df/TICKSPERMIN ),MINPERHOUR),\n      mod(floor(df/TICKSPERSEC ),SECPERMIN),\n      mod(df,TICKSPERSEC)\n  end\n  -- weekday sunday = 0, monday = 1 ...\n  local function weekday(dn) return mod(dn + 1, 7) end\n  -- yearday 0 based ...\n  local function yearday(dn)\n     return dn - dayfromyear((breakdaynum(dn))-1)\n  end\n  -- parse v as a month\n  local function getmontharg(v)\n    local m = tonumber(v);\n    return (m and fix(m - 1)) or inlist(tostring(v) or \"\", sl_months, 2)\n  end\n  -- get daynum of isoweek one of year y\n  local function isow1(y)\n    local f = makedaynum(y, 0, 4) -- get the date for the 4-Jan of year `y`\n    local d = weekday(f)\n    d = d == 0 and 7 or d -- get the ISO day number, 1 == Monday, 7 == Sunday\n    return f + (1 - d)\n  end\n  local function isowy(dn)\n    local w1;\n    local y = (breakdaynum(dn))\n    if dn >= makedaynum(y, 11, 29) then\n      w1 = isow1(y + 1);\n      if dn < w1 then\n        w1 = isow1(y);\n      else\n          y = y + 1;\n      end\n    else\n      w1 = isow1(y);\n      if dn < w1 then\n        w1 = isow1(y-1)\n        y = y - 1\n      end\n    end\n    return floor((dn-w1)/7)+1, y\n  end\n  local function isoy(dn)\n    local y = (breakdaynum(dn))\n    return y + (((dn >= makedaynum(y, 11, 29)) and (dn >= isow1(y + 1))) and 1 or (dn < isow1(y) and -1 or 0))\n  end\n  local function makedaynum_isoywd(y,w,d)\n    return isow1(y) + 7*w + d - 8 -- simplified: isow1(y) + ((w-1)*7) + (d-1)\n  end\n--[[ THE DATE MODULE ]]--\n  local fmtstr  = \"%x %X\";\n--#if not DATE_OBJECT_AFX then\n  local date = {}\n  setmetatable(date, date)\n-- Version:  VMMMRRRR; V-Major, M-Minor, R-Revision;  e.g. 5.45.321 == 50450321\n  do\n    local major = 2\n    local minor = 2\n    local revision = 1\n    date.version = major * 10000000 + minor * 10000 + revision\n  end\n--#end -- not DATE_OBJECT_AFX\n--[[ THE DATE OBJECT ]]--\n  local dobj = {}\n  dobj.__index = dobj\n  dobj.__metatable = dobj\n  -- shout invalid arg\n  local function date_error_arg() return error(\"invalid argument(s)\",0) end\n  -- create new date object\n  local function date_new(dn, df)\n    return setmetatable({daynum=dn, dayfrc=df}, dobj)\n  end\n\n--#if not NO_LOCAL_TIME_SUPPORT then\n  -- magic year table\n  local date_epoch, yt;\n  local function getequivyear(y)\n    assert(not yt)\n    yt = {}\n    local de = date_epoch:copy()\n    local dw, dy\n    for _ = 0, 3000 do\n      de:setyear(de:getyear() + 1, 1, 1)\n      dy = de:getyear()\n      dw = de:getweekday() * (isleapyear(dy) and  -1 or 1)\n      if not yt[dw] then yt[dw] = dy end  --print(de)\n      if yt[1] and yt[2] and yt[3] and yt[4] and yt[5] and yt[6] and yt[7] and yt[-1] and yt[-2] and yt[-3] and yt[-4] and yt[-5] and yt[-6] and yt[-7] then\n        getequivyear = function(y)  return yt[ (weekday(makedaynum(y, 0, 1)) + 1) * (isleapyear(y) and  -1 or 1) ]  end\n        return getequivyear(y)\n      end\n    end\n  end\n  -- TimeValue from date and time\n  local function totv(y,m,d,h,r,s)\n    return (makedaynum(y, m, d) - DATE_EPOCH) * SECPERDAY  + ((h*60 + r)*60 + s)\n  end\n  -- TimeValue from TimeTable\n  local function tmtotv(tm)\n    return tm and totv(tm.year, tm.month - 1, tm.day, tm.hour, tm.min, tm.sec)\n  end\n  -- Returns the bias in seconds of utc time daynum and dayfrc\n  local function getbiasutc2(self)\n    local y,m,d = breakdaynum(self.daynum)\n    local h,r,s = breakdayfrc(self.dayfrc)\n    local tvu = totv(y,m,d,h,r,s) -- get the utc TimeValue of date and time\n    local tml = osdate(\"*t\", tvu) -- get the local TimeTable of tvu\n    if (not tml) or (tml.year > (y+1) or tml.year < (y-1)) then -- failed try the magic\n      y = getequivyear(y)\n      tvu = totv(y,m,d,h,r,s)\n      tml = osdate(\"*t\", tvu)\n    end\n    local tvl = tmtotv(tml)\n    if tvu and tvl then\n      return tvu - tvl, tvu, tvl\n    else\n      return error(\"failed to get bias from utc time\")\n    end\n  end\n  -- Returns the bias in seconds of local time daynum and dayfrc\n  local function getbiasloc2(daynum, dayfrc)\n    local tvu\n    -- extract date and time\n    local y,m,d = breakdaynum(daynum)\n    local h,r,s = breakdayfrc(dayfrc)\n    -- get equivalent TimeTable\n    local tml = {year=y, month=m+1, day=d, hour=h, min=r, sec=s}\n    -- get equivalent TimeValue\n    local tvl = tmtotv(tml)\n\n    local function chkutc()\n      tml.isdst =  nil; local tvug = ostime(tml) if tvug and (tvl == tmtotv(osdate(\"*t\", tvug))) then tvu = tvug return end\n      tml.isdst = true; local tvud = ostime(tml) if tvud and (tvl == tmtotv(osdate(\"*t\", tvud))) then tvu = tvud return end\n      tvu = tvud or tvug\n    end\n    chkutc()\n    if not tvu then\n      tml.year = getequivyear(y)\n      tvl = tmtotv(tml)\n      chkutc()\n    end\n    return ((tvu and tvl) and (tvu - tvl)) or error(\"failed to get bias from local time\"), tvu, tvl\n  end\n--#end -- not NO_LOCAL_TIME_SUPPORT\n\n--#if not DATE_OBJECT_AFX then\n  -- the date parser\n  local strwalker = {} -- ^Lua regular expression is not as powerful as Perl$\n  strwalker.__index = strwalker\n  local function newstrwalker(s)return setmetatable({s=s, i=1, e=1, c=len(s)}, strwalker) end\n  function strwalker:aimchr() return \"\\n\" .. self.s .. \"\\n\" .. rep(\".\",self.e-1) .. \"^\" end\n  function strwalker:finish() return self.i > self.c  end\n  function strwalker:back()  self.i = self.e return self  end\n  function strwalker:restart() self.i, self.e = 1, 1 return self end\n  function strwalker:match(s)  return (find(self.s, s, self.i)) end\n  function strwalker:__call(s, f)-- print(\"strwalker:__call \"..s..self:aimchr())\n    local is, ie; is, ie, self[1], self[2], self[3], self[4], self[5] = find(self.s, s, self.i)\n    if is then self.e, self.i = self.i, 1+ie; if f then f(unpack(self)) end return self end\n  end\n  local function date_parse(str)\n    local y,m,d, h,r,s,  z,  w,u, j,  e,  x,c,  dn,df\n    local sw = newstrwalker(gsub(gsub(str, \"(%b())\", \"\"),\"^(%s*)\",\"\")) -- remove comment, trim leading space\n    --local function error_out() print(y,m,d,h,r,s) end\n    local function error_dup(q) --[[error_out()]] error(\"duplicate value: \" .. (q or \"\") .. sw:aimchr()) end\n    local function error_syn(q) --[[error_out()]] error(\"syntax error: \" .. (q or \"\") .. sw:aimchr()) end\n    local function error_inv(q) --[[error_out()]] error(\"invalid date: \" .. (q or \"\") .. sw:aimchr()) end\n    local function sety(q) y = y and error_dup() or tonumber(q); end\n    local function setm(q) m = (m or w or j) and error_dup(m or w or j) or tonumber(q) end\n    local function setd(q) d = d and error_dup() or tonumber(q) end\n    local function seth(q) h = h and error_dup() or tonumber(q) end\n    local function setr(q) r = r and error_dup() or tonumber(q) end\n    local function sets(q) s = s and error_dup() or tonumber(q) end\n    local function adds(q) s = s + tonumber(\".\"..string.sub(q,2,-1)) end\n    local function setj(q) j = (m or w or j) and error_dup() or tonumber(q); end\n    local function setz(q) z = (z ~= 0 and z) and error_dup() or q end\n    local function setzn(zs,zn) zn = tonumber(zn); setz( ((zn<24) and (zn*60) or (mod(zn,100) + floor(zn/100) * 60))*( zs=='+' and -1 or 1) ) end\n    local function setzc(zs,zh,zm) setz( ((tonumber(zh)*60) + tonumber(zm))*( zs=='+' and -1 or 1) ) end\n\n    if not (sw(\"^(%d%d%d%d)\",sety) and (sw(\"^(%-?)(%d%d)%1(%d%d)\",function(_,a,b) setm(tonumber(a)); setd(tonumber(b)) end) or sw(\"^(%-?)[Ww](%d%d)%1(%d?)\",function(_,a,b) w, u = tonumber(a), tonumber(b or 1) end) or sw(\"^%-?(%d%d%d)\",setj) or sw(\"^%-?(%d%d)\",function(a) setm(a);setd(1) end))\n    and ((sw(\"^%s*[Tt]?(%d%d):?\",seth) and sw(\"^(%d%d):?\",setr) and sw(\"^(%d%d)\",sets) and sw(\"^([,%.]%d+)\",adds) and sw(\"%s*([+-])(%d%d):?(%d%d)%s*$\",setzc))\n      or sw:finish() or (sw\"^%s*$\" or sw\"^%s*[Zz]%s*$\" or sw(\"^%s-([%+%-])(%d%d):?(%d%d)%s*$\",setzc) or sw(\"^%s*([%+%-])(%d%d)%s*$\",setzn))\n      )  )\n    then --print(y,m,d,h,r,s,z,w,u,j)\n    sw:restart(); y,m,d,h,r,s,z,w,u,j = nil,nil,nil,nil,nil,nil,nil,nil,nil,nil\n      repeat -- print(sw:aimchr())\n        if sw(\"^[tT:]?%s*(%d%d?):\",seth) then --print(\"$Time\")\n          _ = sw(\"^%s*(%d%d?)\",setr) and sw(\"^%s*:%s*(%d%d?)\",sets) and sw(\"^([,%.]%d+)\",adds)\n        elseif sw(\"^(%d+)[/\\\\%s,-]?%s*\") then --print(\"$Digits\")\n          x, c = tonumber(sw[1]), len(sw[1])\n          if (x >= 70) or (m and d and (not y)) or (c > 3) then\n            sety( x + ((x >= 100 or c>3) and 0 or x<centuryflip and 2000 or 1900) )\n          else\n            if m then setd(x) else m = x end\n          end\n        elseif sw(\"^(%a+)[/\\\\%s,-]?%s*\") then --print(\"$Words\")\n          x = sw[1]\n          if inlist(x, sl_months,   2, sw) then\n            if m and (not d) and (not y) then d, m = m, false end\n            setm(mod(sw[0],12)+1)\n          elseif inlist(x, sl_timezone, 2, sw) then\n            c = fix(sw[0]) -- ignore gmt and utc\n            if c ~= 0 then setz(c) end\n          elseif not inlist(x, sl_weekdays, 2, sw) then\n            sw:back()\n            -- am pm bce ad ce bc\n            if sw(\"^([bB])%s*(%.?)%s*[Cc]%s*(%2)%s*[Ee]%s*(%2)%s*\") or sw(\"^([bB])%s*(%.?)%s*[Cc]%s*(%2)%s*\") then\n              e = e and error_dup() or -1\n            elseif sw(\"^([aA])%s*(%.?)%s*[Dd]%s*(%2)%s*\") or sw(\"^([cC])%s*(%.?)%s*[Ee]%s*(%2)%s*\") then\n              e = e and error_dup() or 1\n            elseif sw(\"^([PApa])%s*(%.?)%s*[Mm]?%s*(%2)%s*\") then\n              x = lwr(sw[1]) -- there should be hour and it must be correct\n              if (not h) or (h > 12) or (h < 0) then return error_inv() end\n              if x == 'a' and h == 12 then h = 0 end -- am\n              if x == 'p' and h ~= 12 then h = h + 12 end -- pm\n            else error_syn() end\n          end\n        elseif not(sw(\"^([+-])(%d%d?):(%d%d)\",setzc) or sw(\"^([+-])(%d+)\",setzn) or sw(\"^[Zz]%s*$\")) then -- sw{\"([+-])\",{\"(%d%d?):(%d%d)\",\"(%d+)\"}}\n          error_syn(\"?\")\n        end\n      sw(\"^%s*\")  until sw:finish()\n    --else print(\"$Iso(Date|Time|Zone)\")\n    end\n    -- if date is given, it must be complete year, month & day\n    if (not y and not h) or ((m and not d) or (d and not m)) or ((m and w) or (m and j) or (j and w)) then return error_inv(\"!\") end\n    -- fix month\n    if m then m = m - 1 end\n    -- fix year if we are on BCE\n    if e and e < 0 and y > 0 then y = 1 - y end\n    --  create date object\n    dn = (y and ((w and makedaynum_isoywd(y,w,u)) or (j and makedaynum(y, 0, j)) or makedaynum(y, m, d))) or DAYNUM_DEF\n    df = makedayfrc(h or 0, r or 0, s or 0, 0) + ((z or 0)*TICKSPERMIN)\n    --print(\"Zone\",h,r,s,z,m,d,y,df)\n    return date_new(dn, df) -- no need to :normalize();\n  end\n  local function date_fromtable(v)\n    local y, m, d = fix(v.year), getmontharg(v.month), fix(v.day)\n    local h, r, s, t = tonumber(v.hour), tonumber(v.min), tonumber(v.sec), tonumber(v.ticks)\n    -- atleast there is time or complete date\n    if (y or m or d) and (not(y and m and d)) then return error(\"incomplete table\")  end\n    return (y or h or r or s or t) and date_new(y and makedaynum(y, m, d) or DAYNUM_DEF, makedayfrc(h or 0, r or 0, s or 0, t or 0))\n  end\n  local tmap = {\n    ['number'] = function(v) return date_epoch:copy():addseconds(v) end,\n    ['string'] = function(v) return date_parse(v) end,\n    ['boolean']= function(v) return date_fromtable(osdate(v and \"!*t\" or \"*t\")) end,\n    ['table']  = function(v) local ref = getmetatable(v) == dobj; return ref and v or date_fromtable(v), ref end\n  }\n  local function date_getdobj(v)\n    local o, r = (tmap[type(v)] or fnil)(v);\n    return (o and o:normalize() or error\"invalid date time value\"), r -- if r is true then o is a reference to a date obj\n  end\n--#end -- not DATE_OBJECT_AFX\n  local function date_from(arg1, arg2, arg3, arg4, arg5, arg6, arg7)\n    local y, m, d = fix(arg1), getmontharg(arg2), fix(arg3)\n    local h, r, s, t = tonumber(arg4 or 0), tonumber(arg5 or 0), tonumber(arg6 or 0), tonumber(arg7 or 0)\n    if y and m and d and h and r and s and t then\n      return date_new(makedaynum(y, m, d), makedayfrc(h, r, s, t)):normalize()\n    else\n      return date_error_arg()\n    end\n  end\n\n --[[ THE DATE OBJECT METHODS ]]--\n  function dobj:normalize()\n    local dn, df = fix(self.daynum), self.dayfrc\n    self.daynum, self.dayfrc = dn + floor(df/TICKSPERDAY), mod(df, TICKSPERDAY)\n    return (dn >= DAYNUM_MIN and dn <= DAYNUM_MAX) and self or error(\"date beyond imposed limits:\"..self)\n  end\n\n  function dobj:getdate()  local y, m, d = breakdaynum(self.daynum) return y, m+1, d end\n  function dobj:gettime()  return breakdayfrc(self.dayfrc) end\n\n  function dobj:getclockhour() local h = self:gethours() return h>12 and mod(h,12) or (h==0 and 12 or h) end\n\n  function dobj:getyearday() return yearday(self.daynum) + 1 end\n  function dobj:getweekday() return weekday(self.daynum) + 1 end   -- in lua weekday is sunday = 1, monday = 2 ...\n\n  function dobj:getyear()   local r,_,_ = breakdaynum(self.daynum)  return r end\n  function dobj:getmonth() local _,r,_ = breakdaynum(self.daynum)  return r+1 end-- in lua month is 1 base\n  function dobj:getday()   local _,_,r = breakdaynum(self.daynum)  return r end\n  function dobj:gethours()  return mod(floor(self.dayfrc/TICKSPERHOUR),HOURPERDAY) end\n  function dobj:getminutes()  return mod(floor(self.dayfrc/TICKSPERMIN), MINPERHOUR) end\n  function dobj:getseconds()  return mod(floor(self.dayfrc/TICKSPERSEC ),SECPERMIN)  end\n  function dobj:getfracsec()  return mod(floor(self.dayfrc/TICKSPERSEC ),SECPERMIN)+(mod(self.dayfrc,TICKSPERSEC)/TICKSPERSEC) end\n  function dobj:getticks(u)  local x = mod(self.dayfrc,TICKSPERSEC) return u and ((x*u)/TICKSPERSEC) or x  end\n\n  function dobj:getweeknumber(wdb)\n    local wd, yd = weekday(self.daynum), yearday(self.daynum)\n    if wdb then\n      wdb = tonumber(wdb)\n      if wdb then\n        wd = mod(wd-(wdb-1),7)-- shift the week day base\n      else\n        return date_error_arg()\n      end\n    end\n    return (yd < wd and 0) or (floor(yd/7) + ((mod(yd, 7)>=wd) and 1 or 0))\n  end\n\n  function dobj:getisoweekday() return mod(weekday(self.daynum)-1,7)+1 end   -- sunday = 7, monday = 1 ...\n  function dobj:getisoweeknumber() return (isowy(self.daynum)) end\n  function dobj:getisoyear() return isoy(self.daynum)  end\n  function dobj:getisodate()\n    local w, y = isowy(self.daynum)\n    return y, w, self:getisoweekday()\n  end\n  function dobj:setisoyear(y, w, d)\n    local cy, cw, cd = self:getisodate()\n    if y then cy = fix(tonumber(y))end\n    if w then cw = fix(tonumber(w))end\n    if d then cd = fix(tonumber(d))end\n    if cy and cw and cd then\n      self.daynum = makedaynum_isoywd(cy, cw, cd)\n      return self:normalize()\n    else\n      return date_error_arg()\n    end\n  end\n\n  function dobj:setisoweekday(d)    return self:setisoyear(nil, nil, d) end\n  function dobj:setisoweeknumber(w,d)  return self:setisoyear(nil, w, d)  end\n\n  function dobj:setyear(y, m, d)\n    local cy, cm, cd = breakdaynum(self.daynum)\n    if y then cy = fix(tonumber(y))end\n    if m then cm = getmontharg(m)  end\n    if d then cd = fix(tonumber(d))end\n    if cy and cm and cd then\n      self.daynum  = makedaynum(cy, cm, cd)\n      return self:normalize()\n    else\n      return date_error_arg()\n    end\n  end\n\n  function dobj:setmonth(m, d)return self:setyear(nil, m, d) end\n  function dobj:setday(d)    return self:setyear(nil, nil, d) end\n\n  function dobj:sethours(h, m, s, t)\n    local ch,cm,cs,ck = breakdayfrc(self.dayfrc)\n    ch, cm, cs, ck = tonumber(h or ch), tonumber(m or cm), tonumber(s or cs), tonumber(t or ck)\n    if ch and cm and cs and ck then\n      self.dayfrc = makedayfrc(ch, cm, cs, ck)\n      return self:normalize()\n    else\n      return date_error_arg()\n    end\n  end\n\n  function dobj:setminutes(m,s,t)  return self:sethours(nil,   m,   s, t) end\n  function dobj:setseconds(s, t)  return self:sethours(nil, nil,   s, t) end\n  function dobj:setticks(t)    return self:sethours(nil, nil, nil, t) end\n\n  function dobj:spanticks()  return (self.daynum*TICKSPERDAY + self.dayfrc) end\n  function dobj:spanseconds()  return (self.daynum*TICKSPERDAY + self.dayfrc)/TICKSPERSEC  end\n  function dobj:spanminutes()  return (self.daynum*TICKSPERDAY + self.dayfrc)/TICKSPERMIN  end\n  function dobj:spanhours()  return (self.daynum*TICKSPERDAY + self.dayfrc)/TICKSPERHOUR end\n  function dobj:spandays()  return (self.daynum*TICKSPERDAY + self.dayfrc)/TICKSPERDAY  end\n\n  function dobj:addyears(y, m, d)\n    local cy, cm, cd = breakdaynum(self.daynum)\n    if y then y = fix(tonumber(y))else y = 0 end\n    if m then m = fix(tonumber(m))else m = 0 end\n    if d then d = fix(tonumber(d))else d = 0 end\n    if y and m and d then\n      self.daynum  = makedaynum(cy+y, cm+m, cd+d)\n      return self:normalize()\n    else\n      return date_error_arg()\n    end\n  end\n\n  function dobj:addmonths(m, d)\n    return self:addyears(nil, m, d)\n  end\n\n  local function dobj_adddayfrc(self,n,pt,pd)\n    n = tonumber(n)\n    if n then\n      local x = floor(n/pd);\n      self.daynum = self.daynum + x;\n      self.dayfrc = self.dayfrc + (n-x*pd)*pt;\n      return self:normalize()\n    else\n      return date_error_arg()\n    end\n  end\n  function dobj:adddays(n)  return dobj_adddayfrc(self,n,TICKSPERDAY,1) end\n  function dobj:addhours(n)  return dobj_adddayfrc(self,n,TICKSPERHOUR,HOURPERDAY) end\n  function dobj:addminutes(n)  return dobj_adddayfrc(self,n,TICKSPERMIN,MINPERDAY)  end\n  function dobj:addseconds(n)  return dobj_adddayfrc(self,n,TICKSPERSEC,SECPERDAY)  end\n  function dobj:addticks(n)  return dobj_adddayfrc(self,n,1,TICKSPERDAY) end\n  local tvspec = {\n    -- Abbreviated weekday name (Sun)\n    ['%a']=function(self) return sl_weekdays[weekday(self.daynum) + 7] end,\n    -- Full weekday name (Sunday)\n    ['%A']=function(self) return sl_weekdays[weekday(self.daynum)] end,\n    -- Abbreviated month name (Dec)\n    ['%b']=function(self) return sl_months[self:getmonth() - 1 + 12] end,\n    -- Full month name (December)\n    ['%B']=function(self) return sl_months[self:getmonth() - 1] end,\n    -- Year/100 (19, 20, 30)\n    ['%C']=function(self) return fmt(\"%.2d\", fix(self:getyear()/100)) end,\n    -- The day of the month as a number (range 1 - 31)\n    ['%d']=function(self) return fmt(\"%.2d\", self:getday())  end,\n    -- year for ISO 8601 week, from 00 (79)\n    ['%g']=function(self) return fmt(\"%.2d\", mod(self:getisoyear() ,100)) end,\n    -- year for ISO 8601 week, from 0000 (1979)\n    ['%G']=function(self) return fmt(\"%.4d\", self:getisoyear()) end,\n    -- same as %b\n    ['%h']=function(self) return self:fmt0(\"%b\") end,\n    -- hour of the 24-hour day, from 00 (06)\n    ['%H']=function(self) return fmt(\"%.2d\", self:gethours()) end,\n    -- The  hour as a number using a 12-hour clock (01 - 12)\n    ['%I']=function(self) return fmt(\"%.2d\", self:getclockhour()) end,\n    -- The day of the year as a number (001 - 366)\n    ['%j']=function(self) return fmt(\"%.3d\", self:getyearday())  end,\n    -- Month of the year, from 01 to 12\n    ['%m']=function(self) return fmt(\"%.2d\", self:getmonth())  end,\n    -- Minutes after the hour 55\n    ['%M']=function(self) return fmt(\"%.2d\", self:getminutes())end,\n    -- AM/PM indicator (AM)\n    ['%p']=function(self) return sl_meridian[self:gethours() > 11 and 1 or -1] end, --AM/PM indicator (AM)\n    -- The second as a number (59, 20 , 01)\n    ['%S']=function(self) return fmt(\"%.2d\", self:getseconds())  end,\n    -- ISO 8601 day of the week, to 7 for Sunday (7, 1)\n    ['%u']=function(self) return self:getisoweekday() end,\n    -- Sunday week of the year, from 00 (48)\n    ['%U']=function(self) return fmt(\"%.2d\", self:getweeknumber()) end,\n    -- ISO 8601 week of the year, from 01 (48)\n    ['%V']=function(self) return fmt(\"%.2d\", self:getisoweeknumber()) end,\n    -- The day of the week as a decimal, Sunday being 0\n    ['%w']=function(self) return self:getweekday() - 1 end,\n    -- Monday week of the year, from 00 (48)\n    ['%W']=function(self) return fmt(\"%.2d\", self:getweeknumber(2)) end,\n    -- The year as a number without a century (range 00 to 99)\n    ['%y']=function(self) return fmt(\"%.2d\", mod(self:getyear() ,100)) end,\n    -- Year with century (2000, 1914, 0325, 0001)\n    ['%Y']=function(self) return fmt(\"%.4d\", self:getyear()) end,\n    -- Time zone offset, the date object is assumed local time (+1000, -0230)\n    ['%z']=function(self) local b = -self:getbias(); local x = abs(b); return fmt(\"%s%.4d\", b < 0 and \"-\" or \"+\", fix(x/60)*100 + floor(mod(x,60))) end,\n    -- Time zone name, the date object is assumed local time\n    ['%Z']=function(self) return self:gettzname() end,\n    -- Misc --\n    -- Year, if year is in BCE, prints the BCE Year representation, otherwise result is similar to \"%Y\" (1 BCE, 40 BCE)\n    ['%\\b']=function(self) local x = self:getyear() return fmt(\"%.4d%s\", x>0 and x or (-x+1), x>0 and \"\" or \" BCE\") end,\n    -- Seconds including fraction (59.998, 01.123)\n    ['%\\f']=function(self) local x = self:getfracsec() return fmt(\"%s%.9f\",x >= 10 and \"\" or \"0\", x) end,\n    -- percent character %\n    ['%%']=function(self) return \"%\" end,\n    -- Group Spec --\n    -- 12-hour time, from 01:00:00 AM (06:55:15 AM); same as \"%I:%M:%S %p\"\n    ['%r']=function(self) return self:fmt0(\"%I:%M:%S %p\") end,\n    -- hour:minute, from 01:00 (06:55); same as \"%I:%M\"\n    ['%R']=function(self) return self:fmt0(\"%I:%M\")  end,\n    -- 24-hour time, from 00:00:00 (06:55:15); same as \"%H:%M:%S\"\n    ['%T']=function(self) return self:fmt0(\"%H:%M:%S\") end,\n    -- month/day/year from 01/01/00 (12/02/79); same as \"%m/%d/%y\"\n    ['%D']=function(self) return self:fmt0(\"%m/%d/%y\") end,\n    -- year-month-day (1979-12-02); same as \"%Y-%m-%d\"\n    ['%F']=function(self) return self:fmt0(\"%Y-%m-%d\") end,\n    -- The preferred date and time representation;  same as \"%x %X\"\n    ['%c']=function(self) return self:fmt0(\"%x %X\") end,\n    -- The preferred date representation, same as \"%a %b %d %\\b\"\n    ['%x']=function(self) return self:fmt0(\"%a %b %d %\\b\") end,\n    -- The preferred time representation, same as \"%H:%M:%\\f\"\n    ['%X']=function(self) return self:fmt0(\"%H:%M:%\\f\") end,\n    -- GroupSpec --\n    -- Iso format, same as \"%Y-%m-%dT%T\"\n    ['${iso}'] = function(self) return self:fmt0(\"%Y-%m-%dT%T\") end,\n    -- http format, same as \"%a, %d %b %Y %T GMT\"\n    ['${http}'] = function(self) return self:fmt0(\"%a, %d %b %Y %T GMT\") end,\n    -- ctime format, same as \"%a %b %d %T GMT %Y\"\n    ['${ctime}'] = function(self) return self:fmt0(\"%a %b %d %T GMT %Y\") end,\n    -- RFC850 format, same as \"%A, %d-%b-%y %T GMT\"\n    ['${rfc850}'] = function(self) return self:fmt0(\"%A, %d-%b-%y %T GMT\") end,\n    -- RFC1123 format, same as \"%a, %d %b %Y %T GMT\"\n    ['${rfc1123}'] = function(self) return self:fmt0(\"%a, %d %b %Y %T GMT\") end,\n    -- asctime format, same as \"%a %b %d %T %Y\"\n    ['${asctime}'] = function(self) return self:fmt0(\"%a %b %d %T %Y\") end,\n  }\n  function dobj:fmt0(str) return (gsub(str, \"%%[%a%%\\b\\f]\", function(x) local f = tvspec[x];return (f and f(self)) or x end)) end\n  function dobj:fmt(str)\n    str = str or self.fmtstr or fmtstr\n    return self:fmt0((gmatch(str, \"${%w+}\")) and (gsub(str, \"${%w+}\", function(x)local f=tvspec[x];return (f and f(self)) or x end)) or str)\n  end\n\n  function dobj.__lt(a, b) if (a.daynum == b.daynum) then return (a.dayfrc < b.dayfrc) else return (a.daynum < b.daynum) end end\n  function dobj.__le(a, b) if (a.daynum == b.daynum) then return (a.dayfrc <= b.dayfrc) else return (a.daynum <= b.daynum) end end\n  function dobj.__eq(a, b)return (a.daynum == b.daynum) and (a.dayfrc == b.dayfrc) end\n  function dobj.__sub(a,b)\n    local d1, d2 = date_getdobj(a), date_getdobj(b)\n    local d0 = d1 and d2 and date_new(d1.daynum - d2.daynum, d1.dayfrc - d2.dayfrc)\n    return d0 and d0:normalize()\n  end\n  function dobj.__add(a,b)\n    local d1, d2 = date_getdobj(a), date_getdobj(b)\n    local d0 = d1 and d2 and date_new(d1.daynum + d2.daynum, d1.dayfrc + d2.dayfrc)\n    return d0 and d0:normalize()\n  end\n  function dobj.__concat(a, b) return tostring(a) .. tostring(b) end\n  function dobj:__tostring() return self:fmt() end\n\n  function dobj:copy() return date_new(self.daynum, self.dayfrc) end\n\n--[[ THE LOCAL DATE OBJECT METHODS ]]--\n  function dobj:tolocal()\n    local dn,df = self.daynum, self.dayfrc\n    local bias  = getbiasutc2(self)\n    if bias then\n      -- utc = local + bias; local = utc - bias\n      self.daynum = dn\n      self.dayfrc = df - bias*TICKSPERSEC\n      return self:normalize()\n    else\n      return nil\n    end\n  end\n\n  function dobj:toutc()\n    local dn,df = self.daynum, self.dayfrc\n    local bias  = getbiasloc2(dn, df)\n    if bias then\n      -- utc = local + bias;\n      self.daynum = dn\n      self.dayfrc = df + bias*TICKSPERSEC\n      return self:normalize()\n    else\n      return nil\n    end\n  end\n\n  function dobj:getbias()  return (getbiasloc2(self.daynum, self.dayfrc))/SECPERMIN end\n\n  function dobj:gettzname()\n    local _, tvu, _ = getbiasloc2(self.daynum, self.dayfrc)\n    return tvu and osdate(\"%Z\",tvu) or \"\"\n  end\n\n--#if not DATE_OBJECT_AFX then\n  function date.time(h, r, s, t)\n    h, r, s, t = tonumber(h or 0), tonumber(r or 0), tonumber(s or 0), tonumber(t or 0)\n    if h and r and s and t then\n       return date_new(DAYNUM_DEF, makedayfrc(h, r, s, t))\n    else\n      return date_error_arg()\n    end\n  end\n\n  function date:__call(arg1, ...)\n    local arg_count = select(\"#\", ...) + (arg1 == nil and 0 or 1)\n    if arg_count  > 1 then return (date_from(arg1, ...))\n    elseif arg_count == 0 then return (date_getdobj(false))\n    else local o, r = date_getdobj(arg1);  return r and o:copy() or o end\n  end\n\n  date.diff = dobj.__sub\n\n  function date.isleapyear(v)\n    local y = fix(v);\n    if not y then\n      y = date_getdobj(v)\n      y = y and y:getyear()\n    end\n    return isleapyear(y+0)\n  end\n\n  function date.epoch() return date_epoch:copy()  end\n\n  function date.isodate(y,w,d) return date_new(makedaynum_isoywd(y + 0, w and (w+0) or 1, d and (d+0) or 1), 0)  end\n  function date.setcenturyflip(y)\n    if y ~= floor(y) or y < 0 or y > 100 then date_error_arg() end\n    centuryflip = y\n  end\n  function date.getcenturyflip() return centuryflip end\n\n-- Internal functions\n  function date.fmt(str) if str then fmtstr = str end; return fmtstr end\n  function date.daynummin(n)  DAYNUM_MIN = (n and n < DAYNUM_MAX) and n or DAYNUM_MIN  return n and DAYNUM_MIN or date_new(DAYNUM_MIN, 0):normalize()end\n  function date.daynummax(n)  DAYNUM_MAX = (n and n > DAYNUM_MIN) and n or DAYNUM_MAX return n and DAYNUM_MAX or date_new(DAYNUM_MAX, 0):normalize()end\n  function date.ticks(t) if t then setticks(t) end return TICKSPERSEC  end\n--#end -- not DATE_OBJECT_AFX\n\n  local tm = osdate(\"!*t\", 0);\n  if tm then\n    date_epoch = date_new(makedaynum(tm.year, tm.month - 1, tm.day), makedayfrc(tm.hour, tm.min, tm.sec, 0))\n    -- the distance from our epoch to os epoch in daynum\n    DATE_EPOCH = date_epoch and date_epoch:spandays()\n  else -- error will be raise only if called!\n    date_epoch = setmetatable({},{__index = function() error(\"failed to get the epoch date\") end})\n  end\n\n--#if not DATE_OBJECT_AFX then\nreturn date\n--#else\n--$return date_from\n--#end\n"}