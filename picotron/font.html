<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8">
  <title>Picotron Font Editor</title>
  <style>
    :root {
      --bg: #f0f0f0;
      --fg: #222;
      --panel-bg: #fff;
      --border: #ccc;
      --accent: #007acc;
      --hover: #e0e0e0;
    }
    [data-theme="dark"] {
      --bg: #1e1e1e;
      --fg: #ddd;
      --panel-bg: #2a2a2a;
      --border: #444;
      --accent: #3399ff;
      --hover: #333;
    }
    body {
      font-family: 'monospace;';
      background: var(--bg);
      color: var(--fg);
      padding: 0 300px;
      transition: background 0.3s, color 0.3s;
    }
    h1 {
      margin-bottom: 16px;
      font-size: 1.8rem;
      text-align: center;
    }
    #controls {
      background: var(--panel-bg);
      padding: 12px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: center;
      margin-bottom: 16px;
      border: 1px solid var(--border);
    }
    input[type="file"] {
      padding: 4px;
    }
    button {
      background: var(--accent);
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 8px 16px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: background 0.2s;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }
    button:not(:disabled):hover {
      background: var(--hover);
      color: var(--fg);
    }
    #main {
      display: flex;
      gap: 32px;
      height: calc(100vh - 140px);
    }
    #codepoint-grid {
      flex: 0 0 auto;
      display: grid;
      grid-template-columns: repeat(16, min-content);
      gap: 2px;
      padding: 4px;
      background: var(--panel-bg);
      border-radius: 4px;
      border: 1px solid var(--border);
      overflow-y: auto;
    }
    .codepoint {
      display: flex;
      flex-direction: column;
      align-items: center;
      cursor: pointer;
      padding: 4px;
      border: 1px solid var(--border);
      border-radius: 4px;
      transition: background 0.2s, border-color 0.2s;
    }
    .codepoint:hover {
      background: var(--hover);
    }
    .codepoint.selected {
      border-color: var(--accent);
      background: var(--hover);
    }
    .codepoint-label {
      font-size: 8px;
      margin-top: 2px;
      color: var(--fg);
    }
    #editor {
      width: 720px;
      background: var(--panel-bg);
      padding: 16px;
      border-radius: 8px;
      border: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      align-items: center;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    #editor-canvas {
      image-rendering: pixelated;
      background: var(--bg);
      border: 1px solid var(--border);
      cursor: crosshair;
      margin-bottom: 8px;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
    }
    #editor-label {
      font-size: 0.9rem;
      color: var(--fg);
    }
    #codepoint-grid::-webkit-scrollbar,
    body::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    #codepoint-grid::-webkit-scrollbar-thumb,
    body::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <h1>Picotron Font Editor</h1>
  <div id="controls">
    <input type="file" id="file-input" />
    <button id="save-btn" disabled>Save .font</button>
    <button id="theme-toggle">Toggle Dark Mode</button>
  </div>
  <div id="main">
    <div id="codepoint-grid"></div>
    <div id="editor">
      <canvas id="editor-canvas"></canvas>
      <div id="editor-label">Select a character to edit</div>
    </div>
  </div>

  <script>
    const previewScale = 4;
    const editScale = 40;
    const editorCanvas = document.getElementById('editor-canvas');
    editorCanvas.width  = 8 * editScale;
    editorCanvas.height = 8 * editScale;
    let fontBytes = new Uint8Array(2048);
    let selectedIndex = null;
    let isMouseDown = false;
    let drawMode = true;

    function parsePod(podText) {
      const match = podText.match(/--\[\[pod\]\]userdata\("u8",\s*2048,\s*"hex:([0-9A-Fa-f]+)"\)/);
      return match ? match[1] : null;
    }
    function hexToBytes(hex) {
      const clean = hex.replace(/\s+/g, '');
      const bytes = new Uint8Array(clean.length/2);
      for (let i=0; i<bytes.length; i++) bytes[i] = parseInt(clean.substr(i*2,2),16);
      return bytes;
    }
    function bytesToHex(bytes) {
      return Array.from(bytes).map(b=>b.toString(16).padStart(2,'0')).join('');
    }

    function drawGlyph(ctx, glyph, scale) {
      ctx.clearRect(0,0,8*scale,8*scale);
      ctx.fillStyle = varGet('--fg');
      glyph.forEach((row,y)=>{
        for (let x=0; x<8; x++) {
          if (row & (1<<x)) ctx.fillRect(x*scale, y*scale, scale, scale);
        }
      });
    }
    function varGet(name) {
      return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    }
    function drawCodepointPreview(i) {
      const cp = document.querySelector(`.codepoint[data-index="${i}"]`);
      if (!cp) return;
      const ctx = cp.querySelector('canvas').getContext('2d');
      drawGlyph(ctx, fontBytes.slice(i*8, i*8+8), previewScale);
    }
    function setupCodepointGrid() {
      const grid = document.getElementById('codepoint-grid');
      grid.innerHTML = '';
      selectedIndex = null;
      document.getElementById('editor-label').textContent = 'Select a character to edit';
      document.getElementById('save-btn').disabled = true;
      for (let i = 0; i < 256; i++) {
        const cp = document.createElement('div');
        cp.className = 'codepoint';
        cp.dataset.index = i;
        const c = document.createElement('canvas');
        c.width = 8 * previewScale;
        c.height = 8 * previewScale;
        cp.appendChild(c);
        const lbl = document.createElement('div');
        lbl.className = 'codepoint-label';
        lbl.textContent = i.toString(16).padStart(2,'0').toUpperCase();
        cp.appendChild(lbl);
        cp.addEventListener('click', () => selectCodepoint(i));
        grid.appendChild(cp);
        drawCodepointPreview(i);
      }
    }

    function selectCodepoint(i) {
      selectedIndex = i;
      document.querySelectorAll('.codepoint').forEach(el =>
        el.classList.toggle('selected', +el.dataset.index === i)
      );
      document.getElementById('editor-label').textContent = `Editing: 0x${i.toString(16).padStart(2,'0').toUpperCase()}`;
      drawEditor();
      document.getElementById('save-btn').disabled = false;
    }

    function drawEditor() {
      const ctx = editorCanvas.getContext('2d');
      ctx.clearRect(0,0,8*editScale,8*editScale);
      if (selectedIndex === null) return;
      drawGlyph(ctx, fontBytes.slice(selectedIndex*8, selectedIndex*8+8), editScale);
    }
    function applyDraw(x, y) {
      if (selectedIndex === null) return;
      const idx = selectedIndex*8 + y;
      const mask = 1 << x;
      if (drawMode) fontBytes[idx] |= mask;
      else fontBytes[idx] &= ~mask;
      drawEditor();
      drawCodepointPreview(selectedIndex);
    }
    function handleMouseDown(e) {
      if (selectedIndex === null) return;
      isMouseDown = true;
      const r = editorCanvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - r.left) / editScale);
      const y = Math.floor((e.clientY - r.top) / editScale);
      if (x < 0 || x > 7 || y < 0 || y > 7) return;
      const idx = selectedIndex*8 + y;
      drawMode = !(fontBytes[idx] & (1<<x));
      applyDraw(x, y);
    }
    function handleMouseMove(e) {
      if (!isMouseDown) return;
      const r = editorCanvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - r.left) / editScale);
      const y = Math.floor((e.clientY - r.top) / editScale);
      if (x < 0 || x > 7 || y < 0 || y > 7) return;
      applyDraw(x, y);
    }
    function handleMouseUp() { isMouseDown = false; }

    document.getElementById('file-input').addEventListener('change', e => {
      const f = e.target.files[0];
      if (!f) return;
      const r = new FileReader();
      r.onload = () => {
        const hx = parsePod(r.result);
        if (hx && hx.length === 4096) fontBytes = hexToBytes(hx);
        else alert('Invalid POD file');
        setupCodepointGrid();
      };
      r.readAsText(f);
    });

    document.getElementById('save-btn').addEventListener('click', () => {
      const hx = bytesToHex(fontBytes);
      const pod = `--[[pod]]userdata("u8",2048,"hex:${hx}")`;
      const blob = new Blob([pod], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'font.font';
      link.click();
    });

    const themeToggle = document.getElementById('theme-toggle');
    function setTheme(t) {
      document.documentElement.setAttribute('data-theme', t);
      themeToggle.textContent = t === 'light' ? 'Dark Mode' : 'Light Mode';
      localStorage.setItem('theme', t);
    }
    themeToggle.addEventListener('click', () => {
      const next = document.documentElement.getAttribute('data-theme') === 'light' ? 'dark' : 'light';
      setTheme(next);


      for (let i = 0; i < 256; i++) {
        drawCodepointPreview(i);
      }

      drawEditor();
    });
    window.addEventListener('DOMContentLoaded', () => {
      const saved = localStorage.getItem('theme') || 'light';
      setTheme(saved);
      setupCodepointGrid();
    });

    editorCanvas.addEventListener('mousedown', handleMouseDown);
    editorCanvas.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  </script>
</body>
</html>
